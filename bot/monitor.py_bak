import aiohttp
import ssl
import socket
import asyncio
import re
import json
from ipwhois import IPWhois
from datetime import datetime
from cryptography import x509
from cryptography.hazmat.backends import default_backend

#async def check_http(url):
#    try:
#        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:
#            async with session.get(url) as resp:
#                return resp.status == 200
#    except:
#        return False

async def check_http(url, retries=5, delay=120):
    timeout = aiohttp.ClientTimeout(total=15)
    headers = {"User-Agent": "Mozilla/5.0 (compatible; DevCheckBot/1.0)"}

    for attempt in range(retries):
        try:
            async with aiohttp.ClientSession(timeout=timeout, headers=headers) as session:
                async with session.get(url, allow_redirects=True) as resp:
                    if 200 <= resp.status < 300:
                        return True
        except Exception as e:
            print(f"[Attempt {attempt+1}] Error checking {url}: {e}")
        await asyncio.sleep(delay)

    return False

async def check_ssl(url):
    hostname = url.replace("https://", "").replace("http://", "").split("/")[0].lower()
    try:
        ctx = ssl.create_default_context()
        with socket.create_connection((hostname, 443), timeout=5) as sock:
            with ctx.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert(True)
                x509_cert = x509.load_der_x509_certificate(cert, default_backend())
                expire_date = x509_cert.not_valid_after
                return (expire_date - datetime.utcnow()).days
    except:
        return -1

async def check_domain_expiry(url):
    hostname = url.replace("https://", "").replace("http://", "").split("/")[0].lower()
    hostname = hostname.replace("www.", "")
    parts = hostname.split(".")
    if len(parts) > 2:
        return -2  # –ü–æ–¥–¥–æ–º–µ–Ω ‚Äî –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º

    try:
        proc = await asyncio.create_subprocess_exec(
            "whois", hostname,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL
        )
        stdout, _ = await asyncio.wait_for(proc.communicate(), timeout=7)
        text = stdout.decode(errors="ignore")

        # –ü–æ–∏—Å–∫ —Å—Ç—Ä–æ–∫–∏ —Å –¥–∞—Ç–æ–π
        match = re.search(
            r"(paid-till|expiry date|expiration date)[\s:]+([0-9T:\-\.Z]+)",
            text, flags=re.IGNORECASE
        )
        if not match:
            return -1

        date_str = match.group(2).strip()

        for fmt in ("%Y-%m-%d", "%Y-%m-%dT%H:%M:%SZ", "%d-%b-%Y", "%Y.%m.%d"):
            try:
                expire = datetime.strptime(date_str, fmt)
                return (expire - datetime.utcnow()).days
            except:
                continue
        return -1
    except:
        return -1


async def get_geo_info(url: str) -> str:
    try:
        hostname = url.replace("https://", "").replace("http://", "").split("/")[0].lower()
        ip = socket.gethostbyname(hostname)

        # –ü–æ–ª—É—á–∏–º –±–∞–∑–æ–≤—É—é —Å—Ç—Ä–∞–Ω—É —á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–µ–µ API (–±—ã—Å—Ç—Ä–æ)
        async with aiohttp.ClientSession() as session:
            async with session.get(f"https://ipapi.co/{ip}/json/") as resp:
                data = await resp.json()
                country = data.get("country_name", "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
                region = data.get("region", "")
                location = f"{country}, {region}".strip(", ")

        # –ü–æ–ª—É—á–∏–º ASN –∏–∑ whois (–º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 1‚Äì2 —Å–µ–∫.)
        obj = IPWhois(ip)
        res = obj.lookup_rdap(depth=1)
        asn = res.get("asn", "‚Äî")
        org = res.get("asn_description", "").split(",")[0]

        return f"üåê IP: {ip}\nüìç –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ: {location}\nüõ∞Ô∏è ASN: {asn} ({org})"
    except Exception as e:
        return "‚ö†Ô∏è GeoIP/ASN –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"

